## Итоговый проект Алгоритмы и структура данных
## Проект состоит из следующих модулей:

# 1. GeneratePresetImpl
Назначение: Генерация армии с использованием жадного алгоритма.

Основной функционал:
Сортировка юнитов по эффективности (отношение атаки к стоимости, затем здоровья к стоимости)
Распределение юнитов по игровому полю (3×21 клеток)
Управление бюджетом (ограничение по очкам)
Уникальное позиционирование без коллизий

Ключевые особенности:
Использует жадный алгоритм для оптимального распределения юнитов
Проверка уникальности координат через Set
Ограничение максимального количества юнитов одного типа (11 единиц)

# 2. SimulateBattleImpl
Назначение: Симуляция боя между двумя армиями.

Основной функционал:
Поочередное выполнение раундов боя
Сортировка юнитов по силе атаки для определения порядка ходов
Расчет урона с учетом бонусов атаки и защиты
Управление состоянием юнитов (здоровье, жизнь)

Ключевые особенности:
Учет бонусов атаки против определенных типов юнитов
Учет бонусов защиты против определенных типов атак
Логирование боевых действий

# 3. SuitableForAttackUnitsFinderImpl
Назначение: Поиск юнитов, доступных для атаки.

Основной функционал:
Анализ позиций юнитов по строкам
Определение свободных соседних позиций для атаки
Поддержка направления атаки (влево/вправо)

Ключевые особенности:
Работа с группировкой юнитов по рядам
Проверка возможности атаки на основе свободных позиций
Простой и эффективный алгоритм поиска

# 4. UnitTargetPathFinderImpl
Назначение: Поиск пути от атакующего юнита к цели с использованием алгоритма A*.

Основной функционал:
Реализация алгоритма A* для поиска пути
Учет препятствий (других юнитов)
8-направленное движение (включая диагонали)
Расчет оптимального пути с учетом стоимости перемещения

Ключевые особенности:
Эвристика Манхэттенского расстояния
Приоритетная очередь для оптимизации поиска
Восстановление пути от цели к началу

## Запуск проекта

# Требования
 - Java (версия 21 или выше)
 - Для сборки проекта используется Gradle

# Сборка и запуск
 Командная строка - gradle jar
 
## Сложность алгоритмов

# 1. GeneratePresetImpl - Жадный алгоритм O(n log n)
Данный участок кода использует метод sort из класса Collections. Здесь применяется сортировка TimSort - сложность данного алгоритма O(n log n). Сортировка TimSort - гибридный алгоритм, который использует алгоритм бинарной вставки для малых подмассивов и сортировку слиянием для объединения отсортированных участков.

Collections.sort(units, new Comparator<Unit>() {
    @Override
    public int compare(Unit first, Unit second) {
        double firstAttackValue = (double) first.getBaseAttack() / first.getCost();
        double secondAttackValue = (double) second.getBaseAttack() / second.getCost();
        if (firstAttackValue != secondAttackValue) {
            return Double.compare(secondAttackValue, firstAttackValue);
        }
        double firstHealthValue = (double) first.getHealth() / first.getCost();
        double secondHealthValue = (double) second.getHealth() / second.getCost();
        return Double.compare(secondHealthValue, firstHealthValue);
    }
});

Основной алгоритм заполнения армии имеет сложность O(n), так как состоит из вложенных циклов, где внутренний цикл ограничен константой (максимум 11 юнитов одного типа). Проверка коллизий и выбор координат ограничен 63 ячейками (3×21), что считается константой O(1).

Итоговая сложность: O(n log n) из-за доминирующей сортировки.

# 2. SimulateBattleImpl - Алгоритм симуляции боя O(n² log n)

Алгоритм имеет несколько уровней вложенности:
Цикл while (O(n)) - количество раундов
Два цикла по армиям (O(n) каждый) - сбор живых юнитов
Сортировка TimSort (O(n log n)) - сортировка всех активных юнитов
Цикл по всем юнитам (O(n)) - выполнение атак

С учетом вложенности:
Сбор живых юнитов: O(n) + O(n) = O(n)
Сортировка: O(n log n) (внутри цикла раундов)
Выполнение атак: O(n) (внутри цикла раундов)
Наихудший случай, когда в каждом раунде остаются почти все юниты: O(n² log n)

# 3. SuitableForAttackUnitsFinderImpl - Линейный алгоритм O(n)

Алгоритм состоит из:
Внешнего цикла по рядам (максимум 6 рядов - константа)
Двух внутренних циклов по юнитам в ряду
Каждый юнит обрабатывается дважды: один раз для заполнения множества занятых позиций, и один раз для проверки доступности атаки.

Общая сложность: O(n), где n - общее количество юнитов.

# 4. UnitTargetPathFinderImpl - Алгоритм A* O(n)

Алгоритм состоит из:

Инициализация препятствий: O(n) - проход по всем юнитам
Алгоритм A*: В худшем случае O(bᵈ), где b - коэффициент ветвления (8 направлений), d - глубина пути
Восстановление пути: O(p), где p - длина пути

В контексте игрового поля 27×21 (567 клеток), алгоритм работает эффективно. Поскольку количество юнитов ограничено и распределено по полю, практическая сложность близка к O(n) для инициализации, а поиск пути зависит от размера поля, а не от количества юнитов.
